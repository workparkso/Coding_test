## 배열 만들기 2

#### 문제 설명
정수 l과 r이 주어졌을 때, l 이상 r이하의 정수 중에서 숫자 "0"과 "5"로만 이루어진 모든 정수를 오름차순으로 저장한 배열을 return 하는 solution 함수를 완성해 주세요.

만약 그러한 정수가 없다면, -1이 담긴 배열을 return 합니다.

---

#### 제한사항
- 1 ≤ l ≤ r ≤ 1,000,000

---

#### 입출력 예
| l  | r   | result                            |
|----|-----|-----------------------------------|
| 5  | 555 | [5, 50, 55, 500, 505, 550, 555]   |
| 10 | 20  | [-1]                              |

          


---
#### 입출력 예 설명
##### 입출력 예 #1

- 5 이상 555 이하의 0과 5로만 이루어진 정수는 작은 수부터 5, 50, 55, 500, 505, 550, 555가 있습니다. 따라서 [5, 50, 55, 500, 505, 550, 555]를 return 합니다.

##### 입출력 예 #2
- 10 이상 20 이하이면서 0과 5로만 이루어진 정수는 없습니다. 따라서 [-1]을 return 합니다.

----
#### 풀이(개인)
```
def solution(l, r):
    result = [i for i in range(l, r+1) if set(str(i)) <= {'0', '5'}]
    return result if result else [-1]

```
사실 처음에 풀리지 않아서, 참고 자료를 보고 풀게 되었다.
- set(str(i)):
 str(i)를 집합(set)으로 변환하여 숫자의 자릿수를 집합 형태로 만든다. 예를 들어, 숫자 505는 {'5', '0'} 집합으로 변환된다.

- set(str(i)) <= {'0', '5'}:
이 조건은 i의 자릿수를 집합으로 만들고, 그것이 {'0', '5'} 집합의 부분집합인지 확인한다. 
즉, 숫자 i의 모든 자릿수가 0 또는 5로만 이루어져 있는지 체크하는 것이다.

- return result if result else [-1]:
 result 리스트가 비어 있지 않으면 result를 반환하고, 비어 있으면 [-1]을 반환한다.
---

#### 다른 사람들의 풀이
```
1. def solution(l, r):
    answer = []  # 결과를 저장할 리스트 초기화
    for num in range(l, r + 1):  # l부터 r까지 숫자 범위에 대해 반복
        if not set(str(num)) - set(['0', '5']):  # 숫자 num의 각 자리가 0 또는 5로만 이루어져 있는지 확인
            answer.append(num)  # 조건을 만족하면 answer 리스트에 추가
    return answer if answer else [-1]  # 결과가 있으면 answer를 반환, 없으면 [-1] 반환

2. def solution(l, r):
    answer = []
    n = [5,50,55,500,505,550,555,5000,5005,5050,5055,5500,5505,5550,5555,50000,50005,50050,50055,50500,50505,50550,50555,55000,55005,55050,55055,55500,55505,55550,55555,500000,500005,500050,500055,500500,500505,500550,500555,505000,505005,505050,505055,505500,505505,505550,505555,550000,550005,550050,550055,550500,550505,550550,550555,555000,555005,555050,555055,555500,555505,555550,555555]
    for i in n:
        if i >= l and i <= r:
            answer.append(i)
    if answer == []:
        answer.append(-1)
    return answer

3. def solution(l, r):
    answer = []  # 결과를 저장할 리스트 초기화
    i = 1  # 초기 i 값 (이 값은 2진수 변환에서 사용됨)
    n = 5  # 시작 숫자 (5의 배수)
    
    while True:  # 무한 루프 시작
        if n > r:  # n이 r보다 크면 종료
            break
        n = 5 * int(bin(i)[2:])  # i를 2진수로 바꾸고, 그 값을 정수로 변환 후 5를 곱함
        if l <= n <= r:  # n이 l과 r 사이에 있으면
            answer.append(n)  # answer 리스트에 추가
        i += 1  # i 값 증가
    
    return [-1] if len(answer) == 0 else answer  # answer가 비어 있으면 [-1] 반환, 아니면 answer 반환


이진법으로 문제푸는 방법이 신기했다.

```
---
다른 사람들의 풀이 중 2번째 풀이 방법으로부터, 다음과 같은 생각이 들었다.
문제가 안풀리면, 일단 범위를 보고, 범위 내 모든 구성을 다 써서라도 풀어야겠다는 생각이 들었다.